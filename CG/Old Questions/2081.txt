drawback of sutherland hodgeman polygon clipping:
only works for convex clipping wondows


bspline curve:
-degree odesnt depend on no. of control points,more reliable than Bez
-approximation spline curve
-provides local control thorugh control points over eaach segemtn of cu
-add/modify any no. of control points to change shape of curve
without affecting degree of polynomial
-b spilkne blending function aka basic funciotn tha combine cnotrol
points to creates mooth curve/sruface
-blending function not necessarily non zero

rgb model:
additive color model in which r g b light are added to reproduce colo
r=b=g=0 black r=b=g=255 white
yellow r=255 g=255 b=0

bsp tree:
method of visible surface detection
dividing a 3d scene into 2 parts repeadtedly until certain condition
are satified
-a partitionainig plane is chosen
-objects in scene are split into front and back regions
-process contrinues recursively until each part meets requered condoi
efficiltyn organizes 3d space for redering and collsion detection
helps in visibilty determination

algorithm:
-select polygon P from list
-make node N in bsp tree nad add P to list of polygons at that node
-for each polygon in  list
	-if polygon wholly infront of plane containg P, move polygon
	to list of nodes infron tof P
	-if whoilly behind polane containing P, move to behind P
	-if intersected by plane contaiing P,split into 2p olygons 
	and move behidn and infonrt respectively
	-if lies in plane containg P, add to list at node N
-apply to list of polygons in front of P
-apply behind P

refresh rate:
no. of times per sec iamge is drawn to give illsuion of non flickerin
light emitted by phospohorus fades rapidly(persistence) so electron
beam has to be directed at same pint to redraw image repeatedly

vector/random scan display:
elctron beam direclty strikes target pixel instead of scanning each ro
pixel defintion is stored in refresh display file containing set
of line drawing commands to generate image
eg plotter
faster 
cant display realistic iamge with deateail and shadow

bezier curve:
spline generated by using set of onctrol points and polynomial func

-degree is one less than no. of control points
-always passes through 1st and last control points
-contained in convex hull defined by control opints
-convex hull ensures that polynomial smoothly follows control opnits
-blednign function is always posistive and sum is 1
-slope at the beginning of curve is along line joinging 1st 2 control
points and slope at end of line is along ilne joing last 2 opitns

depth buffer/z buffer method:
image space approach of visible surface detection
compare surface depth measured along z axis at each pixel position on
projection plane
each surface of a scene is processed separately one point at a time
developed by CAtmull
z coordinate must be normalized o<z<1
0:back clipping plane
1:front clipping plane

reuquire 2 bufefrs:
z/depth buffer: stores depth values for each pixel position (x,y)
fram/referse hbuffer: stores surafce intesnsity value/ color value
for each pixel position
as surface are proocessed,image buffer is used to sotre colro values
of each pizel postion and z buffer is used to store depth value for 
each x,y postion

algorthm:
-initialize depth and refresh buffer for all buffer position x,y
	depth(x,y)=0
	refresh(x,y)=I backgr
		whre Iback is value of backgr intensity
-process each polygon surface in a ascene one at a time
	-calculate depth z for each x,y, position on polygon
	-ifz>depth(x,y)
		depth(x,y)=z
		refresh(x,y)=Isur(x,y)
			where Isur(x,y) is surface internsity at
			pixel position x,y
-after all pixels and surfaces are compared, draw object using
x,y,z depth nad intesnity refresh buffer
-after all surfaces have been procssed, depth bufer contains depth
value for visible surface and refresh buffer contains coresponding
intesity value for those surface
	depth value for surfa ceposition (x,y) is
		z=(-Ax-By-D)/C
	for next position in scanline z' at(x+1,y)
		z'=z-A/c

scanline method:
extension of scan line algo for filling ploygon interior
as each scan line is processed, all polygon surfaces intersecting
that line are examined to determine which are visible
across each scan line, depth calcualitnos are made ofr each overlaping
surface to determine which is nearrest to viewplane
whne visible surface has been determined, intensity value for that
position is enterd in refresh buffer

data sruct:
edge table:
-enpoint coordinate for each line in a scene
-inverse slope of each line
-pointesr into polygon table to indentify surface bounded by each line

surface table:
coeff of plane eqn for each surface
internsity info for each surface
pointers tpo edge table

activ edge list:
keep track of eihch edges are intersectd by given sacn line

algorithm:
initialize necesasry data srutce:
edge table containg:
	end point coordinates
	onverse slope
	polygon table pinter
surface table:
	coeff
	surface intensity
active edge list:
	flag for each surface
for each scan line
	udpate edge list
	determine point of intersection and set surface on/off
	if flag=on, store value in refresh buffer
	if mroe than one surface=on, do depth sorting and store
	intesinty of surface newrest to view plane in refresh buffer

opengl functions:
glVertex2f(x,y): specief 2d vertex in floating point format
glColor3f(red,gree,blue): specify wanted colr in floating point

pixel:
void display()
{
	//set background color to black opqaue
	glClearColor(0.0f,0.0f,0.0f,1.0f);
	//clear color buffer(bg)
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_POINTS);
		glColor3f(1.0,0.0,1.0);
		glVertex2f(0.2,0.7);
	glEnd();
	glFlush(); //render now
}

square:
void display()
{
	//set background color to black opqaue
	glClearColor(0.0f,0.0f,0.0f,1.0f);
	//clear color buffer(bg)
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_POLYGON);
		glColor3f(1.0f,0.0f,1.0f);
		glVertex2f(0.0f, 0.0f);
    		glVertex2f(0.5f, 0.0f);
    		glVertex2f(0.5f, 0.5f);
   		glVertex2f(0.0f, 0.5f);
	glEnd();
	glFlush(); //render now
}

projection:
represnting n dimensional object into n-1 deminsional medium
defined by mapping of object in project plane

perspective:
simuletes how eye/camera caputres projects 2d scene in 2d plane
farther object from viewer,smaller it appears
vanishing point: all projection lines appera to meet at single point
perspective foreshrteing: object appear samller from center of project

one point: one vanish point, x y parallel to projection plane
2 point:2 vanish points, z axis parallel to projection plane
3 point: 3 v points,no parallel axis

parallel:
object coordinates are transformed to viewplane parallely

orthogrpahic:
projection lines are perpendiculalr to view plane 90

multiview:
one side of object is visible at a time 
top view: object is viewed from top angle
side view
front view

axonometric:
multiple sides of object are visible at a time
isometric: all proj line make equal angle with princiapl axes same are
dietric: 2 equal anglw 2 reara 
trimetrix: no equal angle no area

oblique:
not perpendicular
vavlier: 45
cabinet: 63.4

illumination model:
clculate intensity of light reflectat at given point on a surface

ambient light:
indirect light that comes from all directions
deostn originate from specfiic source but is scattered light in envi
used to ensure objcets arent cmopeletly dark even if not directl liy
independnt of viewer and objectposition
dependent of consant factor in rgb cahnnel

-constant illumination:
same amount of ambient light reaches all object regardless of positon
/oerintation
-no sptaial/diretccional properties:
uniformyl dsitrbuted and doesnt come from specific direction lile sun
-costnat reflection:
intesnty reflected from surface is same regardless of veiwna angle
-dpeendent on surface properties: reflected light depss on matreail 
of object,bright reflect more,dark absrob more
	I amb=Ka Ia
	I: intesntiy of reflected light
	K: surface ambient reflectlity 0 to 1
	I: ambient light inetesity

diffuse/lambertian reflection:
when some intersity of light falls on object surface and it reflect 
in all diection in equal amount, result reflection
indepednet of viewer posiotn
dependent of light position surface osition

	I diff=Kd Ip (NL)
	I: inteinsty of reflect light
	Ip: opint light intensti
	N: surface normal
	L: light direction

specular reflection:
light reflection from shiny surface like mirror metal at certain angle
dependent on light source position, iverwer psotion
	I spec=W(theta) I I cos^n(phi)
	w(theta): Ks
	L: direction of light source
	N: normal to surface
	R:d irection of reflected raay
	V: direction of obsrever
	phi: angle between R V
	theta: angle between L R

phong model:
ineration betwen light nad surface has 3 distinct cmopents
ambient specular diffurse

intensity attenuation:
grdula decrease in intensity of lgiht as it travles from ligh tsource
used to simulate how real world light behaves over distance to make
scene more realistsic
cause:
distance: farther travel,weaker
absorption,scattering:by particles in absr
 I=I0/Kc+Kld+Kqd2
I=final intersnity at point
I0=initial intesity of light source
d=disatnce from light source to point
Kc=constant attenuation(to prevent compelte darkenes)
Kl=linear attenueation(cnotrl how light faeds linealry)
Kq=quadratic attenuation(smiluaer real world lgiht fall off)

sweep repressnetaiton:
solid modeling is technique in cg to repesrnt 3d objects with well
define strctiures for operatins like rednring,collision detection
phyiscal simutlation in our compter
sweep is ued to make 3d from 2d having same symmetry
moving 2d shape laong a path in space

-translational sweepp:
2d shape in moved along straight path to geenrated solid obetc
shape is unchanged during translation

-rotaional:
2d shape in rotaed about an axis to form 3d solid instead of mov liear
